"""
До сих пор мы изучили Get CRUD, валидация данных с использованием Annotated Path Pydantic и шаблонов
В этом модуле мы используя APIRouter создаем структуру проекта, где форматы и типы данных содержатся в одной папке
и модулях, а маршруты в другой с модулем main, соединяющим их в единую программу.

    Что такое маршруты (Routers)?
Маршруты — это функции, которые обрабатывают HTTP-запросы.
В FastAPI маршруты описываются через аннотации @app.get(), @app.post() и другие. Однако, если проект становится крупным,
определение всех маршрутов в одном файле ведёт к путанице. Чтобы избежать этого, используется объект APIRouter,
позволяющий разнести маршруты по модулям:
"""

from fastapi import APIRouter

router = APIRouter()


@router.get("/example")
def example_route():
    return {"message": "This is an example route"}

# В FastAPI APIRouter и FastAPI служат разным целям, хотя оба используются для создания маршрутов (endpoints).
# Давайте разберем, чем они отличаются:
#   1. FastAPI (app = FastAPI())
# FastAPI — это основной класс, который представляет собой приложение. Это точка входа для вашего веб-приложения.
# Вы используете app = FastAPI() для создания экземпляра приложения, к которому затем добавляются маршруты, middleware,
# обработчики ошибок и другие компоненты.

#   2. APIRouter (router = APIRouter())
# APIRouter — это инструмент для организации маршрутов в модульной структуре. Он позволяет разделять маршруты на
# отдельные модули или файлы, что упрощает поддержку и масштабирование приложения. Вы создаете экземпляр APIRouter и
# добавляете к нему маршруты, а затем подключаете этот роутер к основному приложению (app).
# Пример с использованием example_route выше:
# from fastapi import FastAPI
# app = FastAPI()
# app.include_router(router)


"""
    Что такое схемы (schemas), их роль в FastAPI и как их использовать?
Схемы (schemas) — это структуры данных, которые описывают формат и типы входящих/выходящих данных.
FastAPI использует библиотеку Pydantic, которая позволяет автоматически проверять, соответствует ли запрос или ответ 
описанным типам данных.
    Зачем нужны схемы?
Валидация данных: Проверка соответствия данных описанным типам.
Документация: Автоматическое описание структуры данных в Swagger.
Улучшение читаемости: Разделение логики обработки данных и их структуры.

Организацию проекта с разделением логики на папки и файлы.
Чтобы код был читаемым и поддерживаемым, важно грамотно структурировать проект. Пример структуры:

shop_project/
├── app/
│ ├── routers/
│ │ ├── __init__.py
│ │ ├── category.py
│ │ ├── products.py
│ ├── schemas/
│ │ ├── __init__.py
│ │ ├── category.py
│ │ ├── product.py
│ ├── main.py

routers/: Здесь находятся файлы с маршрутизаторами для различных частей проекта (например, категории и продукты).
schemas/: Здесь описаны модели данных (schemas) с использованием Pydantic.
main.py: Главный файл, в котором запускается приложение и подключаются маршруты.
    
    


    Реализацию CRUD-операций для категорий и продуктов.
    
    Прочее по отысканию максимального значения в списке словарей.
- max(user['x'] for user in users) и max(user.get('x') for user in users), если ключ x (или id) присутствует во всех 
словарях в списке users, то оба варианта, сработают одинаково и вернут одно и то же максимальное значение.

- max(user.get('id') for user in users if 'id' in user), как и max(user['id'] for user in users if 'id' in user),
работают корректно, если ключ id отсутствует в некоторых словарях. Конструкция if 'id' in user отфильтрует только 
те словари, где ключ id присутствует, и передаст их значения в max.

- Можно ли использовать max(user['id'] for user in users, default=0) и max(user.get('id') for user in users, default=0)? 
Равнозначны ли они? Да, можно использовать оба варианта, но они не равнозначны, и их поведение отличается.
    a) max(user['id'] for user in users, default=0)
    Этот код использует прямое обращение к ключу id через user['id'].
    Если ключ id отсутствует хотя бы в одном из словарей, возникнет исключение KeyError.
    Параметр default=0 сработает только в случае, если список users пуст. 
    Если список не пуст, но ключ id отсутствует будет ошибка.
    b) max(user.get('id') for user in users, default=0)
    Этот код использует метод get, который возвращает None, если ключ id отсутствует.
    Если ключ id отсутствует в каком-либо из словарей, метод get вернет None, и исключение не возникнет.
    Однако, если в списке users есть словари, где ключ id отсутствует, и get возвращает None, это может привести 
    к ошибке при сравнении None с другими значениями (например, числами).
    Параметр default=0 сработает, если список users пуст или
    если все значения user.get('id') равны None.
    
    Задание списка словарей
- categories = [{id: 1, 'name': 'Electronics'}, {id: 2, 'name': 'Books'}]
Это стандартный способ создания списка словарей в Python. Здесь: categories — это список, содержащий два словаря. 
Каждый словарь имеет ключи id и name. Это корректный и рабочий код.

- categories = list({id: 1, 'name': 'Electronics'}, {id: 2, 'name': 'Books'})
Эта запись некорректна и вызовет ошибку. Причина:
Функция list() ожидает один аргумент — итерируемый объект (например, список, кортеж и т. д.).
В данном случае передаются два отдельных словаря, что вызовет ошибку TypeError.
Исправить это можно, передав список словарей в list(): 
categories = list([{'id': 1, 'name': 'Electronics'}, {'id': 2, 'name': 'Books'}])
Но это избыточно, так как list() здесь не нужен — достаточно просто использовать квадратные скобки для создания списка.

- from typing import List, TypedDict
class Category(TypedDict):
    id: int
    name: str
categories: List[Category] = [{'id': 1, 'name': 'Electronics'}, {'id': 2, 'name': 'Books'}]

или

from pydantic import BaseModel
from typing import List

class Category(BaseModel):
    id: int
    name: str

categories: List[Category] = [
    Category(id=1, name='Electronics'),
    Category(id=2, name='Books')
]

print(categories[0].json())  # Вывод: {"id": 1, "name": "Electronics"}

List[Category] указывает, что categories — это список словарей, где каждый словарь соответствует типу Category.
TypedDict подходит для легковесной аннотации типов словарей.
BaseModel подходит для сложных сценариев, где требуется валидация, сериализация, интеграция с современными фреймворками.
"""